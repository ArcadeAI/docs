# User Stories

### 1. The Toolkit Developer

- As a **Toolkit Developer**, I want to **have my toolkit's documentation updated automatically when I publish a new version**, so that **I don't have to manually run documentation scripts**.

### 2. The Application Developer (Consumer)

- As an **Application Developer**, I want to **access the latest information on required scopes, parameters, and tool definitions in the documentation**, so that **I can implement integrations correctly without relying on outdated or incomplete references**.

### 3. The Documentation Maintainer

- As a **Documentation Maintainer**, I want to **write custom warnings and context for tools that persist across automated updates**, so that **valuable human knowledge isn't overwritten by the generation script**.

### 4. The Product Manager

- As a **Product Manager**, I want to **ensure all toolkits in the documentation have consistent branding (icons, categories)**, so that **the user experience is unified across the marketing site and documentation**.

# Engineering Planning

At the moment toolkit docs are built either manually or using the document generator tool built by Renato. With the increase of toolkits and many required updates, this process is not scalating well. We need to create a new process to build toolkit documentations that are more maintainable and easier to update, also taking the opportunity to improve metadata documentation, as scopes (what was the primary goal for this proj now is a side effect of the sugested process).

Renato's tool lives in the arcade docs repo. It is a CLI tool that requires direct access to the python toolkit source code. So any changes in the toolkits after the documentation is built will require a new manual run in order to have an updated documentation. We will improve this process by getting the tool data from the engine API and combining it with design system metadata to programmatically deal with the documentation generation.

## Tool documentation json as new source of data

Right now tools are mdx files that follow a standard format, for the most part, also there are some LLM or human generated sections for details that require a little more care and need to be brought to the users attention for a better understanding of requirements or limitations of the tool. Instead of still using this approach, MDX components will be used and populated using a new json file that will contain all the required info for the tool, like description, parameters, scopes, secrets, etc, and written MD specific sections, like those generated by some form of reasoning.

NOTE: Latter we can replace this json for an engine api call, when tools metadate feature to accept dynamic data as we can move all the info we need to there.

### Data Merge Architecture

```
┌─────────────────────────────────────────────────────────────────────────────────────────┐
│                                 DATA MERGE PIPELINE                                     │
└─────────────────────────────────────────────────────────────────────────────────────────┘

    SOURCE A: ENGINE API          SOURCE B: DESIGN SYSTEM        SOURCE C: EXISTING DOCS
    (Dynamic Tool Data)           (Toolkit Metadata)             (Manual Content)
    ┌───────────────────┐         ┌───────────────────┐          ┌───────────────────┐
    │ /v1/tools/all     │         │ /metadata/toolkits│          │ .mdx files        │
    │                   │         │                   │          │                   │
    │ • Tools           │         │ • Category        │          │ • Custom Callouts │
    │ • Parameters      │         │ • Icon URL        │          │ • Warnings        │
    │ • Scopes ✅       │         │ • BYOC/Pro flags  │          │ • Extra Context   │
    │ • Auth Info       │         │ • Labels          │          │ • Sub-pages       │
    └─────────┬─────────┘         └─────────┬─────────┘          └─────────┬─────────┘
              │                             │                              │
              └──────────────┬──────────────┴──────────────────────────────┘
                             │
                             ▼
                  ┌───────────────────────┐
                  │    MERGER SCRIPT      │
                  │  (In new repo)        │
                  └──────────┬────────────┘
                             │
                             ▼
                  ┌───────────────────────┐
                  │  MERGED JSON DATA     │
                  │  (One file per kit)   │
                  └──────────┬────────────┘
```

With that goal in mind, we need to define a new json format to store the toolkit documentation data, that must, for at least the moment, be gathered from multiple sources, those being:

- **Engine API**: We must define a new endpoint that will fetch all tools definitions for a toolkit, something like the tools list endpoint but we can make it more focused to this project goal. Probably it will be still a private endpoint that will require a valid API key.
- **Design System**: We will use the design system dependency to get the toolkit metadata, like category, icon, type, flags, etc. Docs already has it as a node pack dependency.
- **Current MDX doc files**: We will use the current MDX doc files to get the custom sections that are written by hand and need to be brought to the users attention for a better understanding of requirements or limitations of the tool. It will be work for a one time script to extract what we need.

### JSON Spec (Annotated with Sources)

The merged JSON format is designed to be the single source of truth for rendering a toolkit's documentation page. It is divided into five logical sections:

1. **Identification**: Basic identity fields like `id` (slug), `label` (display name), `version`, and `description`. These are used for page titles, URLs, and SEO.
2. **Metadata**: Presentation and business logic fields sourced from the Design System. This includes the `category` (for navigation grouping), `icon_url` (for the page header), and flags like `is_byoc` (requires own credentials) and `is_pro` (paid feature).
3. **Authentication**: A summary of the authentication requirements for the toolkit. It aggregates `default_scopes` from all tools to show a high-level view of permissions.
4. **Tools**: The core content. A list of all tools in the toolkit, sourced directly from the Engine API. Each tool object groups **all** relevant data for that tool:
   - `name`, `description`, `parameters` (inputs)
   - `auth` requirements (specific scopes for _this_ tool)
   - `secrets`
   - `output` schema
   - `documentation`: Tool-specific custom content (e.g., callouts, warnings) extracted from existing docs.
5. **Documentation Content**: Toolkit-level custom content that doesn't belong to a specific tool, such as general setup instructions or extended auth details.

```jsonc
{
  // --- IDENTIFICATION ---
  "id": "Github", // [Source: Design System] Unique ID
  "label": "GitHub", // [Source: Design System] Display name
  "version": "1.0.0", // [Source: Engine API] Toolkit version
  "description": "...", // [Source: Engine API] Toolkit description

  // --- METADATA ---
  "metadata": {
    "category": "development", // [Source: Design System]
    "icon_url": "...", // [Source: Design System]
    "is_byoc": false, // [Source: Design System]
    "is_pro": false, // [Source: Design System]
    "toolkit_type": "arcade", // [Source: Design System]
    "docs_link": "..." // [Source: Design System]
  },

  // --- AUTHENTICATION ---
  "auth": {
    "type": "oauth2", // [Source: Engine API] Derived from tool requirements
    "provider_id": "github", // [Source: Engine API]
    "all_scopes": [
      // [Source: Engine API] Union of ALL scopes required by tools
      "repo",
      "user:email"
    ]
  },

  // --- TOOLS ---
  "tools": [
    {
      "name": "CreateIssue", // [Source: Engine API]
      "qualified_name": "Github...", // [Source: Engine API]
      "description": "Creates...", // [Source: Engine API]
      "parameters": [
        // [Source: Engine API]
        {
          "name": "title",
          "type": "string",
          "required": true,
          "description": "..."
        }
      ],
      "auth": {
        "scopes": ["repo"] // [Source: Engine API] Specific scopes for THIS tool
      },
      "secrets": [], // [Source: Engine API]

      // [Source: Existing MDX Docs] Tool-specific manual content
      "documentation": {
        "before_description": {
          "type": "callout",
          "content": "Warning: This tool has specific rate limits..."
        },
        "after_parameters": {
          "type": "markdown",
          "content": "Note on parameter usage..."
        }
      }
    }
  ],

  // --- TOOLKIT DOCUMENTATION ---
  "docs": {
    // [Source: Existing MDX Docs] Toolkit-level manual content
    "custom_imports": [
      "import MyComponent from \"@/app/_components/my-component\";"
    ],
    "sections": {
      "auth_extended": {
        "type": "markdown",
        "content": "Extended explanation about auth setup..."
      },
      "reference_extended": {
        "type": "markdown",
        "content": "Additional reference material..."
      }
    }
  }
}
```

## Engine new endpoint to fetch tool data

For collecting data from the tools in Engine, it is desired to be able to get a list of tools having the provider identifier and the latest version, being the last useful for when there are some tool definition updates getting the data only for this new version and not for all tools with other versions.
Right now engine has a list endpoint that returns the complete tool definition for toolkits, but it does not allow the filtering by version and also has a chuck size limiting (I was informed that is like a few thousends, so not exactly a issue). Those are small details that would probably require some extra work either on the engine or in the consumer side, but I believe that a secret endpoint that we can use as base the list tools one and tailor for the documentation seems a more interesting approach, as one would freely update it depending of the needs for the whole documentation generation workflow and also will avoid being affected by changes or limitations that are required by the list tools endpoint.

Note: After a meeting with Eric and Sergion related to the tool metadata project, I believe that the use of a new dedicate endpoint for the documentation generation got more reasons to be the choice, as we might add in the future some dicts as metadata and do some processing to return it to the docs.

Said that, for this endpoint the OpenAPI scheme looks like this:

### OpenAPI Schema

```yaml
/v1/tools/all:
  get:
    security:
      - Bearer: []
    summary: List All Tools
    description: Returns all tools without pagination, with optional filters. Returns simplified tool schema (no formatted schemas).
    operationId: tools-list-all
    tags:
      - Tools
    parameters:
      - name: provider
        in: query
        description: Filter by auth provider ID (e.g., google, slack, github)
        required: false
        schema:
          type: string
      - name: version
        in: query
        description: Filter by toolkit version
        required: false
        schema:
          type: string
      - name: toolkit
        in: query
        description: Filter by toolkit name
        required: false
        schema:
          type: string
    responses:
      "200":
        description: OK
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/ToolListAllResponse"
      "401":
        description: Unauthorized
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/Error"
      "500":
        description: Internal Server Error
        content:
          application/json:
            schema:
              $ref: "#/components/schemas/Error"
```

### Response Schema

```yaml
components:
  schemas:
    ToolListAllResponse:
      type: object
      required:
        - items
        - total_count
      properties:
        items:
          type: array
          items:
            $ref: "#/components/schemas/ToolSimplified"
        total_count:
          type: integer
          format: int64
          description: Total number of tools returned

    ToolSimplified:
      type: object
      required:
        - fully_qualified_name
        - qualified_name
        - name
        - toolkit
        - input
      properties:
        fully_qualified_name:
          type: string
          description: Full tool identifier including version (e.g., Google.Calendar.CreateEvent@1.0.0)
          example: "Google.Calendar.CreateEvent@1.0.0"
        qualified_name:
          type: string
          description: Tool identifier without version (e.g., Google.Calendar.CreateEvent)
          example: "Google.Calendar.CreateEvent"
        name:
          type: string
          description: Tool name only
          example: "CreateEvent"
        description:
          type: string
          nullable: true
          description: Tool description
        toolkit:
          $ref: "#/components/schemas/ToolkitInfo"
        input:
          $ref: "#/components/schemas/ToolInput"
        output:
          $ref: "#/components/schemas/ToolOutput"
          nullable: true
        requirements:
          $ref: "#/components/schemas/ToolRequirementsSimplified"
          nullable: true

    ToolkitInfo:
      type: object
      required:
        - name
        - version
      properties:
        name:
          type: string
          example: "Google"
        description:
          type: string
          nullable: true
        version:
          type: string
          example: "1.0.0"

    ToolInput:
      type: object
      required:
        - parameters
      properties:
        parameters:
          type: array
          items:
            $ref: "#/components/schemas/ToolParameter"

    ToolParameter:
      type: object
      required:
        - name
        - required
        - value_schema
      properties:
        name:
          type: string
        required:
          type: boolean
        description:
          type: string
          nullable: true
        value_schema:
          $ref: "#/components/schemas/ValueSchema"
        inferrable:
          type: boolean
          default: true

    ValueSchema:
      type: object
      required:
        - val_type
      properties:
        val_type:
          type: string
          description: Data type (string, integer, boolean, array, object, etc.)
        inner_val_type:
          type: string
          nullable: true
          description: For array types, the type of array elements
        enum:
          type: array
          items:
            type: string
          nullable: true

    ToolOutput:
      type: object
      properties:
        available_modes:
          type: array
          items:
            type: string
        description:
          type: string
          nullable: true
        value_schema:
          $ref: "#/components/schemas/ValueSchema"
          nullable: true

    ToolRequirementsSimplified:
      type: object
      description: Simplified requirements - only keys and provider info, no status
      properties:
        authorization:
          $ref: "#/components/schemas/AuthRequirementSimplified"
          nullable: true
        secrets:
          type: array
          items:
            type: string
          description: List of required secret keys
          example: ["API_KEY", "WEBHOOK_SECRET"]

    AuthRequirementSimplified:
      type: object
      description: OAuth2 authorization requirement info (no status)
      properties:
        id:
          type: string
          description: Authorization requirement ID
        provider_id:
          type: string
          nullable: true
          description: Provider identifier (e.g., google, slack)
          example: "google"
        provider_type:
          type: string
          description: Type of provider (oauth2, api_key, etc.)
          example: "oauth2"
        scopes:
          type: array
          items:
            type: string
          nullable: true
          description: Required OAuth2 scopes
          example:
            [
              "https://www.googleapis.com/auth/calendar",
              "https://www.googleapis.com/auth/calendar.events",
            ]
```

### Planning: Engine Code Implementation

To implement this new endpoint in the Engine codebase, those next steps will be followed:

_NOTE: I need feedback from engine engineers herem so they can say if something is wrong or missing._

1. **Define Schema Types**:

   - Create `internal/api/schemas/tools_all.go` to define `ToolListAllResponse`, `ToolSimplified`, and related structs.
   - These structs should mirror the OpenAPI spec, ensuring all necessary fields (especially `scopes`) are included.

2. **Implement Handler**:

   - Add `ListAllToolsHandler` in `internal/api/tool_handlers.go`.
   - This handler needs to:
     - Accept `provider`, `version`, and `toolkit` query parameters.
     - Query the tool catalog/registry efficiently (avoiding pagination logic used in the standard list endpoint).
     - Map the internal tool representation to `ToolSimplified` structs.
     - Extract auth requirements and scopes correctly.

3. **Register Route**:

   - In `internal/api/server.go`, register the new route `GET /tools/all`.
   - Ensure it's protected with appropriate authentication (Bearer token) or API key validation, as this is intended for internal/build-time use.

4. **Documentation**:

   - None docs, at least public available, as it will be a internal use only endpoint.

5. **Testing**:

   - Add unit tests for the new handler to verify filtering logic and response format.

## Design system extraction

The Design System project contains metadata related to marketing and presentation, such as icons, categories, labels, and feature flags (e.g., `isBYOC`). This data is already available as a dependency in the `docs` project, which simplifies access.

We will access this data primarily through the **`lib/metadata`** module exports. Specifically, we will use the `TOOLKIT_CATALOGUE` or the `TOOLKITS` array to look up metadata by toolkit ID.

### Data Source Details

- **Location**: `lib/metadata/` directory.
- **Key Files**:
  - `lib/metadata/toolkits.ts`: Contains the main `TOOLKITS` array definition.
  - `lib/metadata/index.ts`: Exports `TOOLKIT_CATALOGUE` (a record/map for easy lookup by ID).
- **Data Structure (`Toolkit` type)**:
  - `id`: The unique identifier (e.g., "Github", "Gmail"). We will use this to match against Engine API data.
  - `label`: Human-readable name (e.g., "GitHub").
  - `category`: Functional category (e.g., "development", "productivity").
  - `publicIconUrl`: URL to the SVG icon.
  - `isBYOC`: Boolean flag indicating if users need their own credentials.
  - `isPro`: Boolean flag indicating if the toolkit is a paid feature.
  - `type`: Classification like "arcade", "verified", "community".
  - `docsLink`: Full URL to existing docs (useful for cross-referencing).

### Extraction Strategy

The merger script will import the `TOOLKIT_CATALOGUE` from the design system dependency. For each toolkit found in the Engine API response, it will look up the corresponding metadata using the toolkit ID (normalizing case if necessary) and merge the fields into the final JSON structure under the `metadata` key.

## One time script for extract custom sections from already existing docs

We need to preserve valuable, manually written context from the current documentation while migrating to the automated system. This will be achieved by a one-time extraction script.

### Requirements

- **Input**: All MDX files in `app/en/resources/integrations/**/*.mdx`.
- **Output**: A JSON file (`custom_sections.json`) mapping toolkit IDs to their custom content.
- **Logic**: The script must parse MDX files and identify "Custom" vs "Generated" sections based on known patterns (e.g., `<ToolInfo>` is generated, but a specific `<Callout>` might be custom).

### Extraction Targets (Custom Sections)

The script should specifically look for and extract:

1. **Custom Imports**: Any imports that are not part of the standard set (e.g., `import ScopePicker...`).
2. **Toolkit-Level Callouts**: Warnings or info boxes appearing after the header but before the tools list (e.g., Jira's "Handling multiple Atlassian Clouds").
3. **Extended Auth/Reference**: Text that appears after the standard `## Auth` or `## Reference` headers but isn't just the standard link or enum list.
4. **Per-Tool Callouts**: Info boxes inside a specific tool's section (e.g., Gmail's "This tool requires the following scope").
5. **Sub-pages**: Detect if a toolkit has sub-directories like `environment-variables/` and note them for preservation.

### Output Structure

The extracted data will follow the structure defined in the "Documentation Content" section of the main JSON spec, enabling easy merging later.

## Using and updating the documentation generator to build tool json files

At the moment the make docs commands requires access to some python tools source code, to create/update the documentation in the doc repo using MDX files. This process should be updated to use the generated tool data json, instead of MDX files.

The generated docs beside generating structured output based using a defined code logic it also uses LLMs to generate some sections that serves as summary and of the toolkit and its capabilities. This feature will probably be kept for helping the addition of new toolkits but a further analyses on how that would be dealt with in the updated process should be tested, as having it updating sections automatically without human supervision can cause some issue.

One important change that will be added is to kept it easy to change the source of the json with tools data. In this project the json files will be used to generated the docs, but in the future when the addition of metadata to tools definitions we might have all that is required from an engine endpoint.

### Current Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                         USER RUNS SCRIPT                            │
│                    python -m make_toolkit_docs                      │
└─────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│  1. DISCOVER TOOLKITS                                               │
│     File: discovery.py                                              │
│     • Scans home directory for "toolkits" folders                   │
│     • Looks for Python files with @tool decorator                   │
└─────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│  2. USER SELECTS TOOLKIT                                            │
│     File: __main__.py                                               │
│     • Shows fuzzy-searchable list                                   │
│     • User picks one toolkit to document                            │
└─────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│  3. INSTALL TOOLKIT (Dependency!)                                   │
│     File: __main__.py                                               │
│     • Runs: uv pip install -e {toolkit_dir}                         │
│     • Makes toolkit importable in Python                            │
└─────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│  4. LOAD TOOLS (Dependency!)                                        │
│     File: utils.py → get_list_of_tools()                            │
│     • Uses arcade_core to discover tools in runtime                 │
│     • Returns list of ToolDefinition objects                        │
└─────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│  5. BUILD MDX                                                       │
│     File: docs_builder.py → build_toolkit_mdx()                     │
│     • Creates header, TOC, tool specs, footer                       │
└─────────────────────────────────────────────────────────────────────┘
```

### Proposed Flow (Decoupled)

```
┌─────────────────────────────────────────────────────────────────────┐
│                         USER RUNS SCRIPT                            │
│                    python -m make_toolkit_docs                      │
└─────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│  1. FETCH DATA (New Source)                                         │
│     • Reads Merged JSON (API + Metadata + Docs)                     │
│     • NO local Python installation required                         │
│     • NO runtime tool loading                                       │
└─────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│  2. PARSE DATA                                                      │
│     • Deserializes JSON into Tool Definition Objects                │
│     • Extracts scopes, metadata, and custom sections                │
└─────────────────────────────────────────────────────────────────────┘
                                  │
                                  ▼
┌─────────────────────────────────────────────────────────────────────┐
│  3. BUILD MDX                                                       │
│     File: docs_builder.py → build_toolkit_mdx()                     │
│     • Uses templates to render content                              │
│     • Injects custom sections at defined points                     │
│     • Adds new "Scopes" section per tool                            │
└─────────────────────────────────────────────────────────────────────┘
```

## Tool usage code examples generation at run time

The make docs command right now adds a code snippet example for each tool, a js and a python. Most of that code is exact the same for all tools, so instead of creating 2 for each, templates will be used, where only will be required adding the tool call. This approach can simplify updates for all code examples, as they will be rendered from a single source.
Other point that is important is to garanteen that the generate code is syntaxally correct, so a costumer will be able to copy and paste it and run it without compile time errrors. Even if the code is syntactaclly correct, it maybe still be not functional, as some inputs require soem previous knowledge of format or data from the provider, so we wont garanteen that the code will produce a proper result only that inputs follow the right sort of input type as requested in the tool definition.

## CI/CD Pipeline to Build and Deploy Documentation

Documentation updates are currently manual or done locally via the `make docs` command. To automate this, we will add a CI/CD pipeline step to the existing toolkit publishing workflow.

This workflow should trigger when new toolkit versions are released to staging. Since a single release can involve updates to **multiple toolkits simultaneously**, the pipeline must be capable of iterating through a list of changed toolkits and updating the documentation for all of them in a single batch.

### Key Requirements

1. **Trigger**: New release (staging) event, carrying a payload of one or more updated toolkit names/versions.
2. **Versioning Check**: For each toolkit in the payload, verify if the version has actually changed to avoid redundant updates.
3. **Data Gathering**: Loop through all changed toolkits:
   - Fetch latest tool definitions from Engine API.
   - Fetch metadata from Design System.
4. **Generation**:
   - Update the Merged JSON file for each toolkit.
5. **PR Creation**: Create a **single Pull Request** containing updates for all affected toolkits to minimize noise.
6. **Approval**: Manual approval required to merge and publish.

### Pipeline Workflow

```
┌────────────────────────────────────────────────────────────┐
│              RELEASE EVENT (STAGING)                       │
│           Payload: [Toolkit A, Toolkit B, ...]             │
└─────────────────────────────┬──────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────┴──────────────────────────────┐
│  ITERATE THROUGH CHANGED TOOLKITS                          │
│                                                            │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  1. CHECK VERSION                                    │  │
│  │     • Has Toolkit X version changed?                 │  │
│  │     • IF NO: Skip to next                            │  │
│  │     • IF YES: Add to update list                     │  │
│  └──────────────────────────┬───────────────────────────┘  │
│                             │                              │
│                             ▼                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  2. GATHER & MERGE DATA                              │  │
│  │     • Fetch Tool Definitions (Engine API)            │  │
│  │     • Fetch Metadata (Design System)                 │  │
│  │     • Write/Update {toolkit_id}.json                 │  │
│  └──────────────────────────┬───────────────────────────┘  │
│                             │                              │
│                             ▼                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │  3. GENERATE DOCUMENTATION                           │  │
│  │     • Run make_toolkit_docs --from-json              │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                            │
└─────────────────────────────┬──────────────────────────────┘
                              │
                              ▼
┌────────────────────────────────────────────────────────────┐
│  4. CREATE PULL REQUEST                                    │
│     • Commit changes for ALL updated toolkits              │
│     • Open single PR in docs repo                          │
└─────────────────────────────┬──────────────────────────────┘
                              │
                              ▼
┌────────────────────────────────────────────────────────────┐
│  5. MANUAL APPROVAL                                        │
│     • Human reviews changes                                │
│     • Merge PR -> Deploys to Production                    │
└────────────────────────────────────────────────────────────┘
```

## Future changes

After a call with Sergio and Eric we discussed about the current project Eric is working on, where he will enable the addition of metadata to the tools, like tags and categories. Right now in the scope of his work are only already defined fields to be added, a dynamic payload was suggested, as it would allow enriching the tool definition with the data that is stored in design system thus all data that one would need for the docs would have a single source, that would be the Engine API. This would turn all the work related to the processing and merging of tool date from engine + design system unnecessary.
As currently there is not planning on when this feature will be added to the engine, what we can do is making the code modular enough so the data source can be easily swapped.
Besides the centralized source of tools other info would be available that can be added already in the docs when the first iteration of the feature is ready. In case of Eric merging it before this project is finished it probably is worth it to add the support for the metadata he is currently adding even if it would still require both sources for tools definitions.

# Share Planning

For the sharing plan the documentation itself is a manner of sharing the required knowledge to understand our tools with the community. Besides that we can add in the weekly newsletter so we can inform consumers that now our docs are more reliable.

# Measurement Planning

For measurement plan, we can use metrics from the access of tools documentation page and also try to collect user's feedback on how they feel about the documentation after some time of the release.
