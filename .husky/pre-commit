#!/bin/sh
# Exit on any error
set -e

# Check if there are any staged files
if [ -z "$(git diff --cached --name-only)" ]; then
  echo "No staged files to check"
  exit 0
fi

# --- Vale Style Check ---
# Check for staged .md/.mdx files
STAGED_DOCS=$(git diff --cached --name-only --diff-filter=ACMR | grep -E '\.(md|mdx)$' || true)

if [ -n "$STAGED_DOCS" ]; then
  echo "üîç Checking documentation style with Vale..."

  # Run vale-fix script in staged mode (interactive)
  if [ -t 0 ]; then
    # Terminal is interactive - run the fix script
    pnpm vale:fix --staged
  else
    # Non-interactive (CI) - just run vale and report
    echo "$STAGED_DOCS" | xargs vale --output=line || {
      echo "‚ö†Ô∏è  Vale found style issues. Run 'pnpm vale:fix <file>' to fix."
      # Don't block commit for style issues in CI, only toxic language
      # The GitHub Action (Option 1) will handle this later
    }
  fi
fi

# --- Check Redirects (when markdown pages are deleted) ---
# If any page.md/page.mdx files are being deleted, auto-add redirect entries
DELETED_PAGES=$(git diff --cached --name-status | grep -E "^D.*page\.(md|mdx)$" | cut -f2 || true)

if [ -n "$DELETED_PAGES" ]; then
  echo "üîó Detected deleted page(s), checking for redirects..."

  # Run the redirect checker with auto-fix (compares staged changes to HEAD)
  # This will add redirect entries to next.config.ts if missing
  if ! ./scripts/check-redirects.sh --auto-fix HEAD 2>&1; then
    # Stage next.config.ts if it was modified
    if git diff --name-only next.config.ts 2>/dev/null | grep -q "next.config.ts"; then
      git add next.config.ts
      echo ""
      echo "üìù Redirect entries added to next.config.ts and staged."
    fi
    echo ""
    # Check if there are placeholders vs other errors
    if grep -q "REPLACE_WITH_NEW_PATH" next.config.ts 2>/dev/null; then
      echo "‚ùå Commit blocked: Please update the placeholder destinations in next.config.ts"
      echo "   Search for 'REPLACE_WITH_NEW_PATH' and provide actual redirect paths."
    else
      echo "‚ùå Commit blocked: Please fix the redirect issues shown above."
    fi
    exit 1
  fi
fi

# --- Update Internal Links (when redirects are added) ---
# If next.config.ts is staged, update any internal links pointing to redirected paths
if git diff --cached --name-only | grep -q "next.config.ts"; then
  echo "üîó Updating internal links for new redirects..."

  # Run the update script
  if ./scripts/update-internal-links.sh 2>/dev/null; then
    # Stage any files that were modified
    UPDATED_FILES=$(git diff --name-only -- 'app/**/*.mdx' 'app/**/*.tsx' 'app/**/*.md' 2>/dev/null || true)
    if [ -n "$UPDATED_FILES" ]; then
      echo "$UPDATED_FILES" | xargs git add
      echo "‚úÖ Internal links updated and staged"
    fi
  fi
fi

# --- Lint Staged (formatting) ---
pnpm dlx lint-staged

# Store the hash of staged changes to detect modifications
STAGED_HASH=$(git diff --cached | sha256sum | cut -d' ' -f1)

# Save list of staged files (handling all file states)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR)
PARTIALLY_STAGED=$(git diff --name-only)

# Stash unstaged changes to preserve working directory
# --keep-index keeps staged changes in working tree
git stash push --quiet --keep-index --message "pre-commit-stash" || true
STASHED=$?

# Run formatter on the staged files
pnpm dlx ultracite fix
FORMAT_EXIT_CODE=$?

# Restore working directory state
if [ $STASHED -eq 0 ]; then
  # Re-stage the formatted files
  if [ -n "$STAGED_FILES" ]; then
    echo "$STAGED_FILES" | while IFS= read -r file; do
      if [ -f "$file" ]; then
        git add "$file"
      fi
    done
  fi

  # Restore unstaged changes
  git stash pop --quiet || true

  # Restore partial staging if files were partially staged
  if [ -n "$PARTIALLY_STAGED" ]; then
    for file in $PARTIALLY_STAGED; do
      if [ -f "$file" ] && echo "$STAGED_FILES" | grep -q "^$file$"; then
        # File was partially staged - need to unstage the unstaged parts
        git restore --staged "$file" 2>/dev/null || true
        git add -p "$file" < /dev/null 2>/dev/null || git add "$file"
      fi
    done
  fi
else
  # No stash was created, just re-add the formatted files
  if [ -n "$STAGED_FILES" ]; then
    echo "$STAGED_FILES" | while IFS= read -r file; do
      if [ -f "$file" ]; then
        git add "$file"
      fi
    done
  fi
fi

# Check if staged files actually changed
NEW_STAGED_HASH=$(git diff --cached | sha256sum | cut -d' ' -f1)
if [ "$STAGED_HASH" != "$NEW_STAGED_HASH" ]; then
  echo "‚ú® Files formatted by Ultracite"
fi

exit $FORMAT_EXIT_CODE
