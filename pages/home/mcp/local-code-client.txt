import { Steps, Tabs } from "nextra/components";
import { SignupLink } from "@/components/Analytics";

# MCP Local Client

In this guide, you'll learn how to create an MCP client that can connect to a local MCP server.

<Steps>

### Prerequisites

1. Create an <SignupLink utmParams={{
            utm_source: "docs",
            utm_medium: "page",
            utm_campaign: "claude-desktop-client",
          }} linkLocation="docs:claude-desktop-client">Arcade account</SignupLink>
2. Get an [Arcade API key](/home/api-keys)

### Install Dependencies

<Tabs items={["Python", "JavaScript"]} storageKey="preferredLanguage">
<Tabs.Tab>
```bash
pip install mcp
pip install arcade-ai
pip install arcade-google
```
</Tabs.Tab>

<Tabs.Tab>
```bash
npm install @modelcontextprotocol/sdk
npm install -D typescript tsx
```
</Tabs.Tab>

<Tip>
See [Arcade's Integrations](/toolkits) for more toolkits that can be installed.
</Tip>
</Tabs>

### Write your MCP Client

<Tabs items={["Python", "JavaScript"]} storageKey="preferredLanguage">
<Tabs.Tab>
```python
import asyncio

from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client


async def main():
    # Define the command to start the MCP server
    ARCADE_API_KEY = "YOUR_ARCADE_API_KEY_HERE" # Replace with your actual Arcade API key
    PATH_TO_PYTHON = "/path/to/python" # Replace with the path to your Python interpreter
    PATH_TO_ARCADE = "/path/to/arcade" # Replace with the path to the Arcade package
    server_params = StdioServerParameters(
        command="bash",
        args=[
            "-c",
            f"export ARCADE_API_KEY={ARCADE_API_KEY} && {PATH_TO_PYTHON} {PATH_TO_ARCADE} serve --mcp",
        ],
    )

    # Establish a connection to the MCP server using stdio transport
    async with stdio_client(server_params) as streams, ClientSession(*streams) as session:
        # Initialize the session with the server
        await session.initialize()

        # Retrieve the list of available tools from the server
        response = await session.list_tools()

        # Display available tools
        print("Available tools:")
        for tool in response.tools:
            first_line_of_description = tool.description.split("\n")[0]
            print(f"  - {tool.name} ({first_line_of_description})")

        # Call a tool
        response = await session.call_tool(
            name="Google_ListEmails",
            arguments={"limit": 5},
        )

        # Handle the case where the tool returns a URL for authorization
        if response.content[0].type == "text" and response.content[0].text.startswith("https://"):
            print(f"Please go to this URL and authorize the action: {response.content[0].text}")
            input("After completing the authorization flow, press Enter to continue...")
            response = await session.call_tool(
                name="Google_ListEmails",
                arguments={"limit": 5},
            )

        print(response.content[0].text)


# Execute the main function
asyncio.run(main())
```
</Tabs.Tab>

<Tabs.Tab>
```typescript
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport, StdioServerParameters } from "@modelcontextprotocol/sdk/client/stdio.js";
import { CallToolResultSchema } from "@modelcontextprotocol/sdk/types.js";
import * as readline from 'readline';

async function main() {
  try {
    // Define the command to start the MCP server
    const ARCADE_API_KEY = "YOUR_ARCADE_API_KEY_HERE"; // Replace with your actual Arcade API key
    const PATH_TO_PYTHON = "path/to/python"; // Replace with the path to your Python interpreter
    const PATH_TO_ARCADE = "path/to/arcade"; // Replace with the path to the Arcade package

    // Create the server parameters
    const serverParams: StdioServerParameters = {
      command: "bash",
      args: [
        "-c",
        `export ARCADE_API_KEY=${ARCADE_API_KEY} && ${PATH_TO_PYTHON} ${PATH_TO_ARCADE} serve --mcp`,
      ]
    };

    // Create a transport that will start the server
    const transport = new StdioClientTransport(serverParams);

    // Create the client
    const client = new Client({
      name: "typescript-mcp-client",
      version: "1.0.0"
    });

    // Start the transport and connect the client
    await client.connect(transport);

    // Retrieve the list of available tools from the server
    const toolsResponse = await client.listTools();

    // Display available tools
    console.log("Available tools:");
    for (const tool of toolsResponse.tools) {
      const firstLineOfDescription = tool.description?.split("\n")[0];
      console.log(`  - ${tool.name} (${firstLineOfDescription})`);
    }

    // Call a tool with parameters object
    let response = await client.callTool({
      name: "Google_ListEmails",
      arguments: { limit: 5 }
    }, CallToolResultSchema);

    // Handle the case where the tool returns a URL for authorization
    const content = response.content as Array<{ type: string; text: string }> || [];

    if (content.length > 0 && content[0].type === "text" && content[0].text.startsWith("https://")) {
      console.log(`Please go to this URL and authorize the action: ${content[0].text}`);

      // Create readline interface for user input
      const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
      });

      // Wait for user to complete authorization
      await new Promise<void>((resolve) => {
        rl.question("After completing the authorization flow, press Enter to continue...", () => {
          rl.close();
          resolve();
        });
      });

      // Call the tool again after authorization
      response = await client.callTool({
        name: "Google_ListEmails",
        arguments: { limit: 5 }
      }, CallToolResultSchema);
    }

    // Display the response
    const finalContent = response.content as Array<{ type: string; text: string }> || [];

    if (finalContent.length > 0 && finalContent[0].type === "text") {
      console.log(finalContent[0].text);
    } else {
      console.log("Received response:", response);
    }
  } catch (error) {
    console.error("Error:", error);
  }
}

// Execute the main function
main().catch(console.error);

```
</Tabs.Tab>
</Tabs>
</Steps>
